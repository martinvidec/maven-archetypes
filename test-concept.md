# Test Concept and Implementation Guide

## Overview

This document provides comprehensive technical documentation for implementing tests in applications generated by the cloud-ready web application Maven archetype. It serves as a reference for developers to understand the testing strategy, frameworks, and implementation patterns included in the archetype.

## Testing Strategy

### Testing Pyramid

The testing strategy follows the testing pyramid approach with three main levels:

1. **Unit Tests** (Base of pyramid - Most tests)
   - Fast execution
   - Isolated components
   - Mock external dependencies
   - High code coverage

2. **Integration Tests** (Middle layer)
   - Test component interactions
   - Real database and service interactions
   - TestContainers for consistent environments
   - Moderate execution time

3. **End-to-End Tests** (Top layer - Fewest tests)
   - Full application workflow testing
   - User journey validation
   - Production-like environment

## Testing Frameworks and Dependencies

### Core Testing Framework

```xml
<!-- JUnit 5 - Primary testing framework -->
<dependency>
    <groupId>org.junit.jupiter</groupId>
    <artifactId>junit-jupiter</artifactId>
    <scope>test</scope>
</dependency>

<!-- Spring Boot Test Starter -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-test</artifactId>
    <scope>test</scope>
</dependency>

<!-- TestContainers for integration testing -->
<dependency>
    <groupId>org.testcontainers</groupId>
    <artifactId>junit-jupiter</artifactId>
    <scope>test</scope>
</dependency>

<dependency>
    <groupId>org.testcontainers</groupId>
    <artifactId>postgresql</artifactId>
    <scope>test</scope>
</dependency>
```

### Additional Testing Libraries

- **Mockito**: Mocking framework (included in spring-boot-starter-test)
- **AssertJ**: Fluent assertion library (included in spring-boot-starter-test)
- **Hamcrest**: Matcher library for test assertions
- **WireMock**: HTTP service mocking for external API testing
- **JSONPath**: JSON response testing

## Test Configuration

### Application Test Configuration

The archetype includes a comprehensive test configuration file (`application-test.yml`):

```yaml
spring:
  datasource:
    url: jdbc:h2:mem:testdb
    driver-class-name: org.h2.Driver
    username: sa
    password: password
  
  jpa:
    hibernate:
      ddl-auto: create-drop
    show-sql: true
    database-platform: org.hibernate.dialect.H2Dialect
  
  h2:
    console:
      enabled: true
  
  flyway:
    enabled: false
  
  data:
    redis:
      host: localhost
      port: 6370 # Different port for test Redis if needed
  
  cache:
    type: simple # Use simple cache for testing

logging:
  level:
    ${package}: DEBUG
    org.springframework.security: DEBUG

management:
  endpoints:
    web:
      exposure:
        include: "*"
```

### Test Profiles

- **test**: Default test profile using H2 in-memory database
- **integration**: Profile for integration tests with real databases
- **testcontainers**: Profile for TestContainers-based integration tests

## Test Types and Implementation Patterns

### 1. Unit Tests

**Purpose**: Test individual components in isolation

**Characteristics**:
- Fast execution (milliseconds)
- No external dependencies
- Mock all collaborators
- High code coverage

**Example Pattern** (Service Layer):

```java
@ExtendWith(MockitoExtension.class)
class UserServiceTest {

    @Mock
    private UserRepository userRepository;

    @Mock
    private PasswordEncoder passwordEncoder;

    @InjectMocks
    private UserService userService;

    @Test
    void createUser_ShouldReturnUserDto_WhenValidInput() {
        // Given
        CreateUserRequest request = new CreateUserRequest("testuser", "test@example.com");
        User savedUser = new User("testuser", "test@example.com");
        savedUser.setId(1L);
        
        when(userRepository.save(any(User.class))).thenReturn(savedUser);
        when(passwordEncoder.encode(anyString())).thenReturn("encoded-password");

        // When
        UserDto result = userService.createUser(request);

        // Then
        assertThat(result.getId()).isEqualTo(1L);
        assertThat(result.getUsername()).isEqualTo("testuser");
        verify(userRepository).save(any(User.class));
    }
}
```

### 2. Web Layer Tests (Controller Tests)

**Purpose**: Test REST controllers and web layer behavior

**Characteristics**:
- Use `@WebMvcTest` for slice testing
- Mock service layer dependencies
- Test HTTP request/response handling
- Validate JSON serialization/deserialization

**Implementation** (from archetype):

```java
@WebMvcTest(UserController.class)
class UserControllerTest {

    @Autowired
    private MockMvc mockMvc;

    @MockBean
    private UserService userService;

    @Autowired
    private ObjectMapper objectMapper;

    @Test
    @WithMockUser(roles = "ADMIN")
    void getUserById_ShouldReturnUser_WhenUserExists() throws Exception {
        // Given
        Long userId = 1L;
        UserDto userDto = UserDto.builder()
            .id(userId)
            .username("testuser")
            .email("test@example.com")
            .firstName("Test")
            .lastName("User")
            .enabled(true)
            .build();

        when(userService.findById(userId)).thenReturn(Optional.of(userDto));

        // When & Then
        mockMvc.perform(get("/users/{id}", userId))
            .andExpect(status().isOk())
            .andExpect(content().contentType(MediaType.APPLICATION_JSON))
            .andExpect(jsonPath("$.id").value(userId))
            .andExpect(jsonPath("$.username").value("testuser"))
            .andExpect(jsonPath("$.email").value("test@example.com"));
    }

    @Test
    @WithMockUser(roles = "ADMIN")
    void createUser_ShouldReturnCreatedUser_WhenValidInput() throws Exception {
        // Given
        UserDto inputDto = UserDto.builder()
            .username("newuser")
            .email("new@example.com")
            .firstName("New")
            .lastName("User")
            .enabled(true)
            .build();

        UserDto createdDto = UserDto.builder()
            .id(1L)
            .username("newuser")
            .email("new@example.com")
            .firstName("New")
            .lastName("User")
            .enabled(true)
            .build();

        when(userService.create(any(UserDto.class))).thenReturn(createdDto);

        // When & Then
        mockMvc.perform(post("/users")
                .contentType(MediaType.APPLICATION_JSON)
                .content(objectMapper.writeValueAsString(inputDto)))
            .andExpect(status().isCreated())
            .andExpect(content().contentType(MediaType.APPLICATION_JSON))
            .andExpect(jsonPath("$.id").value(1L))
            .andExpect(jsonPath("$.username").value("newuser"));
    }

    @Test
    void getUserById_ShouldReturnUnauthorized_WhenNotAuthenticated() throws Exception {
        // When & Then
        mockMvc.perform(get("/users/1"))
            .andExpect(status().isUnauthorized());
    }
}
```

### 3. Integration Tests

**Purpose**: Test component interactions with real dependencies

**Characteristics**:
- Use TestContainers for real database instances
- Test data persistence and retrieval
- Validate business workflows
- Test security configurations

**Base Integration Test Class** (from archetype):

```java
@SpringBootTest
@AutoConfigureWebMvc
@ActiveProfiles("test")
@Testcontainers
@Transactional
public abstract class BaseIntegrationTest {

    @Container
    static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>("postgres:15-alpine")
            .withDatabaseName("testdb")
            .withUsername("test")
            .withPassword("test");

    @DynamicPropertySource
    static void configureProperties(DynamicPropertyRegistry registry) {
        registry.add("spring.datasource.url", postgres::getJdbcUrl);
        registry.add("spring.datasource.username", postgres::getUsername);
        registry.add("spring.datasource.password", postgres::getPassword);
    }

    @Autowired
    protected MockMvc mockMvc;
}
```

**Implementation Example**:

```java
class UserIntegrationTest extends BaseIntegrationTest {

    @Autowired
    private UserRepository userRepository;

    @Test
    void shouldCreateAndRetrieveUser() {
        // Given
        User user = new User("testuser", "test@example.com", "Test", "User");
        user.setRoles(Set.of(Role.USER));

        // When
        User savedUser = userRepository.save(user);

        // Then
        assertThat(savedUser.getId()).isNotNull();
        assertThat(savedUser.getUsername()).isEqualTo("testuser");
        assertThat(savedUser.getEmail()).isEqualTo("test@example.com");

        // Verify retrieval
        User foundUser = userRepository.findById(savedUser.getId()).orElse(null);
        assertThat(foundUser).isNotNull();
        assertThat(foundUser.getUsername()).isEqualTo("testuser");
    }

    @Test
    void healthEndpoint_ShouldReturnOk() throws Exception {
        mockMvc.perform(get("/actuator/health"))
                .andExpect(status().isOk());
    }
}
```

### 4. Repository Tests

**Purpose**: Test data access layer functionality

**Characteristics**:
- Use `@DataJpaTest` for slice testing
- Test custom queries and repository methods
- Validate entity relationships
- Test data integrity constraints

**Example Pattern**:

```java
@DataJpaTest
@ActiveProfiles("test")
class UserRepositoryTest {

    @Autowired
    private TestEntityManager entityManager;

    @Autowired
    private UserRepository userRepository;

    @Test
    void findByUsername_ShouldReturnUser_WhenUserExists() {
        // Given
        User user = new User("testuser", "test@example.com", "Test", "User");
        entityManager.persistAndFlush(user);

        // When
        Optional<User> result = userRepository.findByUsername("testuser");

        // Then
        assertThat(result).isPresent();
        assertThat(result.get().getEmail()).isEqualTo("test@example.com");
    }

    @Test
    void findByUsername_ShouldReturnEmpty_WhenUserDoesNotExist() {
        // When
        Optional<User> result = userRepository.findByUsername("nonexistent");

        // Then
        assertThat(result).isEmpty();
    }
}
```

### 5. Security Tests

**Purpose**: Test authentication and authorization mechanisms

**Characteristics**:
- Test endpoint security configurations
- Validate role-based access control
- Test authentication flows
- Verify security headers and CORS

**Example Pattern**:

```java
@SpringBootTest
@AutoConfigureWebMvc
@ActiveProfiles("test")
class SecurityIntegrationTest {

    @Autowired
    private MockMvc mockMvc;

    @Test
    @WithMockUser(roles = "USER")
    void userEndpoint_ShouldBeAccessible_ForUserRole() throws Exception {
        mockMvc.perform(get("/api/users/profile"))
            .andExpect(status().isOk());
    }

    @Test
    @WithMockUser(roles = "USER")
    void adminEndpoint_ShouldBeForbidden_ForUserRole() throws Exception {
        mockMvc.perform(get("/api/admin/users"))
            .andExpect(status().isForbidden());
    }

    @Test
    void protectedEndpoint_ShouldRequireAuthentication() throws Exception {
        mockMvc.perform(get("/api/users/profile"))
            .andExpect(status().isUnauthorized());
    }
}
```

## Test Organization and Structure

### Directory Structure

```
src/test/java/
├── controller/          # Controller layer tests
├── service/            # Service layer tests
├── repository/         # Repository layer tests
├── integration/        # Integration tests
├── security/           # Security-related tests
└── util/              # Test utilities and helpers

src/test/resources/
├── application-test.yml
├── data.sql            # Test data
└── schema.sql          # Test schema
```

### Naming Conventions

- **Test Classes**: `{ClassUnderTest}Test` (e.g., `UserServiceTest`)
- **Integration Tests**: `{Feature}IntegrationTest` (e.g., `UserIntegrationTest`)
- **Test Methods**: `{methodUnderTest}_{expectedBehavior}_{condition}`
  - Example: `createUser_ShouldReturnUserDto_WhenValidInput`

## Testing Best Practices

### 1. Test Structure (Given-When-Then)

```java
@Test
void methodName_ShouldExpectedBehavior_WhenCondition() {
    // Given - Setup test data and conditions
    // When - Execute the code under test
    // Then - Verify the results
}
```

### 2. Test Data Management

- Use **Test Data Builders** for complex object creation
- Create **Test Fixtures** for reusable test data
- Use **@Sql** annotations for database test data setup
- Implement **Test Data Factories** for consistent test data

### 3. Mocking Guidelines

- Mock external dependencies only
- Use `@MockBean` for Spring components in integration tests
- Use `@Mock` for unit tests
- Verify interactions when testing behavior, not just return values

### 4. Assertion Best Practices

- Use AssertJ for fluent assertions
- Group related assertions
- Include meaningful failure messages
- Test both positive and negative scenarios

### 5. Test Performance

- Keep unit tests fast (< 100ms each)
- Use TestContainers judiciously for integration tests
- Implement test parallelization where appropriate
- Use test slices (`@WebMvcTest`, `@DataJpaTest`) for focused testing

## TestContainers Configuration

### PostgreSQL Container

```java
@Container
static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>("postgres:15-alpine")
    .withDatabaseName("testdb")
    .withUsername("test")
    .withPassword("test")
    .withReuse(true);
```

### Redis Container

```java
@Container
static GenericContainer<?> redis = new GenericContainer<>("redis:7-alpine")
    .withExposedPorts(6379)
    .withReuse(true);
```

### Best Practices for TestContainers

- Use container reuse for faster test execution
- Share containers between test classes when possible
- Use specific image versions for consistency
- Configure containers with minimal resources needed

## Test Coverage and Quality

### Coverage Requirements

- **Unit Tests**: Minimum 80% line coverage
- **Integration Tests**: Focus on critical business paths
- **Branch Coverage**: Minimum 70% for complex conditional logic

### Quality Metrics

- **Test Maintainability**: Tests should be easy to read and modify
- **Test Reliability**: Tests should be deterministic and not flaky
- **Test Speed**: Unit test suite should run in < 30 seconds

### Tools

- **JaCoCo**: Code coverage measurement
- **SonarQube**: Code quality and test coverage analysis
- **Mutation Testing**: Verify test quality with PIT

## Continuous Integration Integration

### Maven Configuration

```xml
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-surefire-plugin</artifactId>
    <configuration>
        <includes>
            <include>**/*Test.java</include>
        </includes>
        <excludes>
            <exclude>**/*IntegrationTest.java</exclude>
        </excludes>
    </configuration>
</plugin>

<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-failsafe-plugin</artifactId>
    <configuration>
        <includes>
            <include>**/*IntegrationTest.java</include>
        </includes>
    </configuration>
</plugin>
```

### Test Profiles

```xml
<profiles>
    <profile>
        <id>unit-tests</id>
        <activation>
            <activeByDefault>true</activeByDefault>
        </activation>
        <build>
            <plugins>
                <plugin>
                    <groupId>org.apache.maven.plugins</groupId>
                    <artifactId>maven-surefire-plugin</artifactId>
                </plugin>
            </plugins>
        </build>
    </profile>
    
    <profile>
        <id>integration-tests</id>
        <build>
            <plugins>
                <plugin>
                    <groupId>org.apache.maven.plugins</groupId>
                    <artifactId>maven-failsafe-plugin</artifactId>
                </plugin>
            </plugins>
        </build>
    </profile>
</profiles>
```

## Running Tests

### Local Development

```bash
# Run unit tests only
mvn test

# Run integration tests
mvn verify -P integration-tests

# Run all tests
mvn verify

# Run tests with coverage
mvn test jacoco:report

# Run specific test class
mvn test -Dtest=UserServiceTest

# Run specific test method
mvn test -Dtest=UserServiceTest#createUser_ShouldReturnUserDto_WhenValidInput
```

### Docker Environment

```bash
# Start test dependencies
docker-compose up -d postgres redis

# Run tests
mvn verify

# Stop dependencies
docker-compose down
```

## Common Testing Patterns

### 1. Test Data Builders

```java
public class UserTestDataBuilder {
    private String username = "testuser";
    private String email = "test@example.com";
    private String firstName = "Test";
    private String lastName = "User";
    private Set<Role> roles = Set.of(Role.USER);
    private boolean enabled = true;

    public static UserTestDataBuilder aUser() {
        return new UserTestDataBuilder();
    }

    public UserTestDataBuilder withUsername(String username) {
        this.username = username;
        return this;
    }

    public UserTestDataBuilder withEmail(String email) {
        this.email = email;
        return this;
    }

    public UserTestDataBuilder withAdminRole() {
        this.roles = Set.of(Role.ADMIN);
        return this;
    }

    public User build() {
        User user = new User(username, email, firstName, lastName);
        user.setRoles(roles);
        user.setEnabled(enabled);
        return user;
    }
}
```

### 2. Custom Test Annotations

```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
@WithMockUser(roles = "ADMIN")
public @interface WithMockAdmin {
}

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
@WithMockUser(roles = "USER")
public @interface WithMockUser {
}
```

### 3. Test Utilities

```java
public class TestUtils {
    
    public static String asJsonString(Object obj) {
        try {
            return new ObjectMapper().writeValueAsString(obj);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
    
    public static <T> T fromJsonString(String json, Class<T> clazz) {
        try {
            return new ObjectMapper().readValue(json, clazz);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
}
```

## Troubleshooting Common Issues

### 1. TestContainers Issues

**Problem**: Tests fail with "Docker not available"
**Solution**: Ensure Docker is running and accessible to the test environment

**Problem**: Tests are slow with TestContainers
**Solution**: Enable container reuse and use shared containers

### 2. Security Test Issues

**Problem**: Security tests fail with 403 Forbidden
**Solution**: Verify CSRF configuration and use `@WithMockUser` correctly

### 3. Database Test Issues

**Problem**: Tests fail due to data conflicts
**Solution**: Use `@Transactional` and proper test data cleanup

### 4. MockMvc Issues

**Problem**: JSON deserialization errors in controller tests
**Solution**: Ensure proper `@JsonProperty` annotations and ObjectMapper configuration

## Conclusion

This test concept provides a comprehensive foundation for implementing robust testing strategies in applications generated by the cloud-ready web application archetype. By following these patterns and practices, developers can ensure high-quality, maintainable, and reliable applications.

The testing approach emphasizes:
- **Comprehensive Coverage**: Multiple test types covering all application layers
- **Best Practices**: Industry-standard testing patterns and conventions
- **Maintainability**: Clear structure and organization for long-term maintenance
- **Performance**: Efficient test execution and CI/CD integration
- **Quality**: High standards for test reliability and effectiveness

Regular review and updates of testing practices ensure the continued effectiveness of the testing strategy as the application evolves.